(ns sxml-sax.xslt
  "Tools for using SXML to perform XSL Transformations."
  (:require [sxml-sax.xslt.lang :as xsl])
  (:require [sxml-sax.core :as sxml])
  (:import
    (javax.xml.transform TransformerFactory Transformer Result)
    (javax.xml.transform.sax SAXSource)
    (javax.xml.transform.stream StreamSource StreamResult)
    (java.io InputStream OutputStream Reader Writer File StringReader
             StringWriter)))

(defn identity-stylesheet
  "Create an SXML XSLT template that is the identity transform, that is it
  copies the source document to the output document unchanged."
  []
  (xsl/stylesheet "1.0"
    (xsl/match-template "@*|node()"
      (xsl/copy (xsl/apply-templates-to "@*|node()")))))

(derive clojure.lang.IPersistentVector ::sxml)

(defmulti to-source
  "Convert any sort of thing that might function as a source of XML into a
  Source object for transforms."
  class)
(defmethod to-source ::sxml [sx] (sxml/sax-source sx))
(defmethod to-source SAXSource [ss] ss)
(defmethod to-source InputStream [^InputStream ir] (StreamSource. ir))
(defmethod to-source Reader [^Reader r] (StreamSource. r))
(defmethod to-source File [^File f] (StreamSource. f))
(defmethod to-source String [s] (to-source (StringReader. s)))

(derive OutputStream ::adapt-with-streamresult)
(derive Writer ::adapt-with-streamresult)
(derive File ::adapt-with-streamresult)

(defmulti to-result
  "Convert any sort of thing that might function as a sink for XML into a
  vector, the first entry of which is the Result object for transforms. The
  vector may have type metadata for dispatch in the from-result multimethod,
  where any additional entries in the vector may be used to produce the
  result."
  (fn [arg] (if (keyword? arg) arg (class arg))))

(defmethod to-result Result [sr]
  ^{:type ::literal-result} [sr])

(defmethod to-result ::adapt-with-streamresult [r]
  ^{:type ::streamresult-adapted} [(StreamResult. r) r])

(defmethod to-result :string [_]
  (let [sw       (StringWriter.)
        [result] (to-result sw)]
    ^{:type ::string-output} [result sw]))

(defmethod to-result :sxml [_]
  (let [[output result] (sxml/sax-result)]
    ^{:type ::sxml-output} [result output]))

(defmulti from-result
  "Post-process a result vector (as generated by to-result) after a
  transformation to yield the output value."
  type)
(defmethod from-result ::literal-result [r] (first r))
(defmethod from-result ::streamresult-adapted [sra] (second sra))
(defmethod from-result ::string-output [sw] (.toString ^String (second sw)))
(defmethod from-result ::sxml-output [r] @(second r))

(defn compile-template
  "Pre-compile an XSL template into a Transformer. The pre-compiled template
  can be used as the stylesheet argument to transform!, which will prevent it
  having to parse and compile the template on each invocation."
  [ss]
  (binding [sxml/*default-xmlns* (assoc sxml/*default-xmlns* :xsl
                                        "http://www.w3.org/1999/XSL/Transform")]
    (.. (TransformerFactory/newInstance)
      (newTransformer (to-source ss)))))

(defmulti ^{:private true} transformer
  "Create an XSLT Transformer from any sort of thing that might function as a
  source of XML containing the stylesheet."
  class)

(defmethod transformer Transformer [t] t)
(defmethod transformer Object [o] (compile-template o))

(defn transform!
  "Perform XSL Transformations using the given stylesheet and source document
  (either of which can be any type of thing that can function as a source of
  XML data).

  When a result argument is given, the transform is targeted to it and the
  function returns that object. You may pass :string as the result to have the
  outpu in string format, or :sxml to get the result in SXML format. When no
  result argument is given, it defaults to :sxml."
  ([stylesheet source] (transform! stylesheet source :sxml))
  ([stylesheet source result]
   (let [result (to-result result)]
     (.transform ^Transformer (transformer stylesheet)
                 (to-source source)
                 (first result))
     (from-result result))))
